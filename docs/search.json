[
  {
    "objectID": "wtfs/wtf_is_a_gateway.html",
    "href": "wtfs/wtf_is_a_gateway.html",
    "title": "WTF is a ‚Äúgateway‚Äù?",
    "section": "",
    "text": "Figure¬†1: The way out is through.\n\n\n\n\n\n\n\n\n\ntl;dr - It's an overloaded term that means a variety of things depending on context, but a radically oversimplified definition might be \"It controls traffic entering and exiting the cluster\".\n\n\n\n\nPrior Art\nYou can watch my first attempt to address the confusion around this term in this 2022 Istiocon talk. I stand by my original assesment: naming things isn't hard, it's impossible.\n\n\nIt's a kind of deployment\n\nNorth/South gateways\nThe first gateway most Istio users encounter is a type of deployment called an Ingress Gateway. It's a deployment of the exact same istio-proxy container image that's used for sidecars, except without all the iptables redirection. It just sits at the edge of your cluster and allows traffic to enter from the outside (usually through a load balancer) and turns that plain old vanilla traffic into \"meshed\" traffic (eg. wraps it in mTLS and so on).\nIstio also offers something called an Egress Gateway which is also just a deployment of istio-proxy containers sitting at the edge of the cluster, but this time configured as a central point which traffic leaving the mesh must pass through on the way out. This allows users to do things like enforce policy and collect metrics on outbound traffic.\n\n\nEast/West gateways\nWhen deploying an Istio mesh across multiple clusters in the multiple networks model pods in one cluster will be unable to talk directly to pods in another cluster without something to relay those connections for them. That something is an East/West gateway. Similar to North/South it's just another deployment in your cluster, but this time it's managing cross-cluster traffic not inbound/outbound traffic.\n\n\n\nIt's an Istio custom resource\nIstio gateway deployments, be they North/South or East/West can't just start routing traffic on their own. They need configuration to tell them what to do with the traffic they receive. That configuration can be provided in the form of an Istio Gateway resource. That is, a custom resource that you apply to your cluster which istiod will read from the K8s API and translate into a corresponding Envoy configuration which it will beam down to a gateway deployment, providing it the configuration it needs to do its job.\n\n\nIt's a Gateway API custom resource\nIt did not take long for folks who were using the old Ingress resource to run up against limitations. It can't handle TCP or do traffic splitting or handle complex routing rules. Rather than try to fix Ingress SIG-Network developed a new API called Gateway API to address its shortcomings. The Gateway API offers a bunch of new resource types including (you guessed it) a Gateway resource which behaves similarly to the Istio custom resource of the same name."
  },
  {
    "objectID": "wtfs/wtf_did_my_envoy_filter_break_after_upgrading_istio.html",
    "href": "wtfs/wtf_did_my_envoy_filter_break_after_upgrading_istio.html",
    "title": "Why TF did my EnvoyFilter break after upgrading Istio?",
    "section": "",
    "text": "Figure¬†1: Not that kind of filter.\n\n\n\n\n\n\n\n\n\ntl;dr - EnvoyFilter can make arbitrary changes to the Envoy configurations in sidecars and gateways, and the structure of those configurations can change from release to release.\n\n\n\n\nEnvoy Configuration\nAt its core istiod consumes data from the K8s API (resources like VirtalService, Service, Endpoint) and turns them into Envoy configuration. Unlike nginx or haproxy, Envoy config was never intended to be written by hand. Long before xDS was introduced, ancient versions of Envoy docs provided a small python app to generate configs. From day one it has been understood that due to its flexibility Envoy configuration is necessarily complex, dynamic, and vast.\n\nAs an example here I'm fetching the Envoy config from a very small environment with sidecar injection disabled and it is &gt; 200kb of JSON. By contrast, have you ever seen an nginx.conf file that was over 100kb?\n$ istioctl proxy-config all istio-ingressgateway-56558c9fd7-x24kb -ojson | wc -c\n222104\n\nTODO: - someting about the structure part\nTwo key points:\n\nFlexibility: Envoy provides a stunning amount of functionality, of which Istio only utilizes a subset. Features (and their many associated config options) are added to Envoy at a faster rate than Istio adopts them.\nOpinions: Because Istio is an opinionated way to operate Envoy, the structure of the configuration it produces is fairly consistent. A hand written envoy config file will look very different than one Istio produces.\n\n\n\nThe EnvoyFilter CRD\nEnvoyFilter is the \"break glass\" \"I don't care what Istio told you\" \"I know what I'm doing, let me reach inside of Envoy and change things\" CRD. It exists because users want to leverage the many Envoy features for which there is no first class Istio support. For example, there is no RateLimit CRD in Istio. If you want to configure rate limiting it's on you to reach inside Envoy and conjure the correct incantations. But given the size and complexity of the average Envoy config, this needs to be a precision undertaking.\n\n\n\n\n\n\nTip\n\n\n\nCheck out this fantastic Envoycon talk to get an overview of the art of writing an EnvoyFilter.\n\n\n\n\nOkay but why did upgrading Istio break my thing?\nThink of istiod like a compiler, but instead of producing executables it produces Envoy configs. And think of an EnvoyFilter as a binary patch applied to the executable produced by our compiler.\nFrom one release of a compiler to the next, the authors might change all sorts of things about the way the resulting binary gets produced. Maybe they use new CPU instructions, maybe change the way memory gets allocated and organized, maybe they change the way resources like strings and images are stored inside the executable file. As long as the executable it produces functions the same way for the users, most people don't care how it works inside.\nBUT if you're out here patching binaries you sure do care, because if tomorrows shiny new compiler changes something your patch modifies then it's very likely you wind up with a broken binary.\nAnd it's the exact same thing with an EnvoyFilter.\nToday your EnvoyFilter might rely on the fact that Istio uses feature X instead of feature Y to get the job done, but tomorrow's Istio release might use something else and now you're back to square one figuring out how to patch it all over again.\nThe old istio docs used to call this out pretty overtly.\n\nSince this is break glass configuration, there will not be any backward compatibility across different Istio releases. In other words, this configuration is subject to change based on internal implementation of Istio networking subsystem.\n\nThe current docs are a little less blunt.\n\n... any envoy configuration provided through this mechanism should be carefully monitored across Istio proxy version upgrades ...\n\nBut core Istio maintainer John Howard called it out more directly in this github comment where he states:\n\nEnvoyFilter is considered \"highly alpha and not stable\" and we discourage it ...\n\nAnd even more directly in his fantastic blog post about choosing Istio features:\n\n‚ò†Ô∏è Avoid at all costs ‚ò†Ô∏è EnvoyFilter is, objectively, the worst feature in Istio for stability ...\n\nCaveat emptor."
  },
  {
    "objectID": "wtfs/wtf_is_up_with_the_tables_in_the_istio_docs.html",
    "href": "wtfs/wtf_is_up_with_the_tables_in_the_istio_docs.html",
    "title": "WTF is up with these tables in the Istio docs?",
    "section": "",
    "text": "Figure¬†1: For real though what is this?\nOr to put it another way: how am I supposed to know what fields and values should go where when I am crafting Istio custom resources?"
  },
  {
    "objectID": "wtfs/wtf_is_up_with_the_tables_in_the_istio_docs.html#see-also",
    "href": "wtfs/wtf_is_up_with_the_tables_in_the_istio_docs.html#see-also",
    "title": "WTF is up with these tables in the Istio docs?",
    "section": "See Also",
    "text": "See Also\n\nKubernetes\nIstio isn't the only project trying to manage this problem, the K8s API reference suffers from it too. Take a look at the API reference for a Service for instance. It starts off by documenting the top level fields supported by a Service resource, but it doesn't try to recursively itemize every single option you could include under the spec. Instead it refers you to the section for the ServiceSpec type which lists all the available fields it supports, and goes on to refer you to the relevant subsection for any of its own nested object types (eg. Service.spec.ports is a ServicePort object.\nYou can see this play out in the output of kubectl explain as well. It will either show you a detailed explanation of the avialeble fields:\n$ kubectl explain service\nKIND:       Service\nVERSION:    v1\n\nDESCRIPTION:\n    Service is a named abstraction of software service (for example, mysql)\n    consisting of local port (for example 3306) that the proxy listens on, and\n    the selector that determines which pods will answer requests sent through\n    the proxy.\n\nFIELDS:\n  apiVersion    &lt;string&gt;\n    APIVersion defines the versioned schema of this representation of an object.\n    Servers should convert recognized schemas to the latest internal value, and\n    may reject unrecognized values. More info:\n    https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\n\n  kind  &lt;string&gt;\n    Kind is a string value representing the REST resource this object\n    represents. Servers may infer this from the endpoint the client submits\n    requests to. Cannot be updated. In CamelCase. More info:\n    https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\n  metadata  &lt;ObjectMeta&gt;\n    Standard object's metadata. More info:\n    https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata\n\n  spec  &lt;ServiceSpec&gt;\n    Spec defines the behavior of a service.\n    https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\n\n  status    &lt;ServiceStatus&gt;\n    Most recently observed status of the service. Populated by the system.\n    Read-only. More info:\n    https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\nOr it will recursively give you a type-by-type breakdown of every single field supported at every depth level:\n$ kubectl explain service --recursive\nKIND:       Service\nVERSION:    v1\n\nDESCRIPTION:\n    Service is a named abstraction of software service (for example, mysql)\n    consisting of local port (for example 3306) that the proxy listens on, and\n    the selector that determines which pods will answer requests sent through\n    the proxy.\n    \nFIELDS:\n  apiVersion    &lt;string&gt;\n  kind  &lt;string&gt;\n  metadata  &lt;ObjectMeta&gt;\n    annotations &lt;map[string]string&gt;\n    creationTimestamp   &lt;string&gt;\n    deletionGracePeriodSeconds  &lt;integer&gt;\n    deletionTimestamp   &lt;string&gt;\n    finalizers  &lt;[]string&gt;\n    generateName    &lt;string&gt;\n    generation  &lt;integer&gt;\n    labels  &lt;map[string]string&gt;\n    managedFields   &lt;[]ManagedFieldsEntry&gt;\n      apiVersion    &lt;string&gt;\n      fieldsType    &lt;string&gt;\n      fieldsV1  &lt;FieldsV1&gt;\n      manager   &lt;string&gt;\n      operation &lt;string&gt;\n      subresource   &lt;string&gt;\n      time  &lt;string&gt;\n    name    &lt;string&gt;\n    namespace   &lt;string&gt;\n    ownerReferences &lt;[]OwnerReference&gt;\n      apiVersion    &lt;string&gt; -required-\n      blockOwnerDeletion    &lt;boolean&gt;\n      controller    &lt;boolean&gt;\n      kind  &lt;string&gt; -required-\n      name  &lt;string&gt; -required-\n      uid   &lt;string&gt; -required-\n    resourceVersion &lt;string&gt;\n    selfLink    &lt;string&gt;\n    uid &lt;string&gt;\n  spec  &lt;ServiceSpec&gt;\n    allocateLoadBalancerNodePorts   &lt;boolean&gt;\n    clusterIP   &lt;string&gt;\n    clusterIPs  &lt;[]string&gt;\n    externalIPs &lt;[]string&gt;\n    externalName    &lt;string&gt;\n    externalTrafficPolicy   &lt;string&gt;\n    healthCheckNodePort &lt;integer&gt;\n    internalTrafficPolicy   &lt;string&gt;\n    ipFamilies  &lt;[]string&gt;\n    ipFamilyPolicy  &lt;string&gt;\n    loadBalancerClass   &lt;string&gt;\n    loadBalancerIP  &lt;string&gt;\n    loadBalancerSourceRanges    &lt;[]string&gt;\n    ports   &lt;[]ServicePort&gt;\n      appProtocol   &lt;string&gt;\n      name  &lt;string&gt;\n      nodePort  &lt;integer&gt;\n      port  &lt;integer&gt; -required-\n      protocol  &lt;string&gt;\n      targetPort    &lt;IntOrString&gt;\n    publishNotReadyAddresses    &lt;boolean&gt;\n    selector    &lt;map[string]string&gt;\n    sessionAffinity &lt;string&gt;\n    sessionAffinityConfig   &lt;SessionAffinityConfig&gt;\n      clientIP  &lt;ClientIPConfig&gt;\n        timeoutSeconds  &lt;integer&gt;\n    type    &lt;string&gt;\n  status    &lt;ServiceStatus&gt;\n    conditions  &lt;[]Condition&gt;\n      lastTransitionTime    &lt;string&gt; -required-\n      message   &lt;string&gt; -required-\n      observedGeneration    &lt;integer&gt;\n      reason    &lt;string&gt; -required-\n      status    &lt;string&gt; -required-\n      type  &lt;string&gt; -required-\n    loadBalancer    &lt;LoadBalancerStatus&gt;\n      ingress   &lt;[]LoadBalancerIngress&gt;\n        hostname    &lt;string&gt;\n        ip  &lt;string&gt;\n        ports   &lt;[]PortStatus&gt;\n          error &lt;string&gt;\n          port  &lt;integer&gt; -required-\n          protocol  &lt;string&gt; -required-\nBut it won't do both.\n\n\nKubespec\nKubespec.dev is a kickass project that attempts to reconcile both worlds by combining both structure and some reference docs in a single place.\n\n\n\nFigure¬†10: kubespec.dev reference for a K8s Service resource"
  },
  {
    "objectID": "wtfs/wtf_is_up_with_istio_and_ebpf.html",
    "href": "wtfs/wtf_is_up_with_istio_and_ebpf.html",
    "title": "WTF is up with Istio and eBPF?",
    "section": "",
    "text": "Figure¬†1: A service mesh and a programmable kernel walk into a bar.\n\n\n\n\n\n\n\n\n\ntl;dr - Not a damn thing.\n\n\n\n\nIstio does not use eBPF\nFor anything at all.\n\n\nWhy would Istio use eBPF?\nIstio uses iptables to transparently redirect traffic from an application container into a sidecar proxy container so it can do all the fancy service mesh stuff with that traffic, however the iptables redirection adds some (small but nonzero) latency overhead. At large scales that overhead adds up. To alleviate this overhead eBPF can be used to bypass much of the Linux network stack for a nice performance boost. In fact there is a CNCF project called Merbridge that does exactly that for Kuma, Linkerd, and Istio.\n\n\n\n\n\n\ndata path using iptables\n\n\n\n\n\n\n\ndata path using eBPF\n\n\n\n\n\n\n\nAbove images are from the Merbridge docs, which are based on these slides from Thomas Graf's 2018 Kubecon talk \"Accelerating Envoy with the Linux Kernel\".\n\n\n\n\nWhat about this blog post?\nYou mean that 2023 blog post that describes in detail how Istio's shiny new ambient mode leverages eBPF and shows off some sweet performance gains?\n\n\n\n\nQPS when you drink eBPF protein shakes\n\n\n\nSurprise! Istio isn't doing that anymore. It turned out to be very difficult to build this feature in a way that is compatible with every possible CNI plugin out there so the approach was abandoned.\n\n\nWhat about the incident?\nYou mean that thing where the ambient mode eBPF experiment led to a minor dustup with the CNCF over licensing? Well, let me tell you the tale.\nFor backstory, you need to know:\n\nThe CNCF has a list of approved software licenses that CNCF projects can use.\nThe GPL is not on that list.\nLike everything else in the Kernel the eBPF reference implementation is GPL2.0.\n\nIn the fall of 2022 at Kubecon in Detroit, the CTO of Isolavent (the company behind Cilium) opened a PR live on stage against the CNCF technical oversight committee github repo propsing the Cilium project be moved to Graduated status. It takes time for a proposal like that to proceed, and while the process was underway something else happened.\nThe folks at Kong offered to donate their experimental eBPF powered load balancer project called blixt to the CNCF as a sandbox project. During that discussion, well known destroyer of databases and CNCF man about town MrBobbyTables pointed out that the submission was being held until such time as the CNCF could decide what to do about the eBPF bits of the blixt project being licensed under the GPL.\nThis presumably led to several months of hand-wringing and lawyer-consulting while the projects in question waited in limbo to find out their fate.\n\nWhat does any of that have to do with Istio?\nGood question! In the middle of all this Istio also applied for CNCF graduation and looked like they were going to breeze right through the process until someone quite rightfully pointed out that if Cilium couldn't graduate because it was using eBPF then it didn't seem at all fair to let Istio go ahead now did it?\nSince Istio wasn't doing much with eBPF anyway it was easy to rip out the offending code and get on with life. But it wasn't so straightforward for blixt and Cilium which are built on eBPF from the ground up.\nIf you want a detailed explanation of the subtleties of eBPF licensing you can read this brief summary or this detailed explanation or watch this talk, but if you just want to know how the story ends the CNCF resolved to adopt a blanket licensing exception for in kernel eBPF programs and documented it for posterity.\nThe blixt project was successfully donated to the CNCF, both the Cilium and Istio projects quite deservedly made their way to graduated status, and they all lived happily ever after!\n\nüåá"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "WTF is this?\nThis is a collection of explanations for things that have been known to confuse newcomers to the Istio project.\n\n\nWhy TF does this exist?\nI offer training professionally and support the Istio community casually as time permits, and I wanted to have a detailed reference to link folks to when common questions come up.\n\n\nWTF should I do if this site answered my question?\nThrow me a high five if you see me at Kubecon, share what you've learned with a colleague, and if you're in the market for some cloud training keep me in mind.\n\n\nWTF should I do if my question isn't answered here?\nCheck out this lightning talk from Istio Day 2025 for a quick summary of how to get help."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "istio.wtf",
    "section": "",
    "text": "WTF is NR filter chain not found?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWTF is \"upstream\" and \"downstream\"?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWTF is a \"gateway\"?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWTF is the Istio CNI?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWTF is the difference between mTLS and TLS?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWTF is up with Istio and eBPF?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWTF is up with these tables in the Istio docs?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWhy TF did my EnvoyFilter break after upgrading Istio?\n\n\n¬†\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "wtfs/wtf_is_the_difference_between_mTLS_and_TLS.html",
    "href": "wtfs/wtf_is_the_difference_between_mTLS_and_TLS.html",
    "title": "WTF is the difference between mTLS and TLS?",
    "section": "",
    "text": "Figure¬†1: Ketchup or catsup?"
  },
  {
    "objectID": "wtfs/wtf_is_the_difference_between_mTLS_and_TLS.html#footnotes",
    "href": "wtfs/wtf_is_the_difference_between_mTLS_and_TLS.html#footnotes",
    "title": "WTF is the difference between mTLS and TLS?",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nBy default Istio mints its own mTLS client certs and distributes them to each pod in the mesh, but it can also integrate with other projects which manage workload identites like SPIRE.‚Ü©Ô∏é"
  },
  {
    "objectID": "wtfs/wtf_is_upstream_and_downstream.html",
    "href": "wtfs/wtf_is_upstream_and_downstream.html",
    "title": "WTF is \"upstream\" and \"downstream\"?",
    "section": "",
    "text": "Figure¬†1: These terms have nothing to do with water.\n\n\n\n\n\n\n\n\n\ntl;dr - \"downstream\" is where connections come from and \"upstream\" is where they go.\n\n\n\n\nIt's Not About Water\nThroughout the Istio docs you'll find the terms \"upstream\" and \"downstream\" used in a way which may be counterintuitive to you. This terminology has been imported wholesale from the Envoy project which documents the terms clearly but does not explain why the terms are used this way.\nThe confusion often arises when using the hydrological definition instead of a technical one. Istio and Envoy use the terms in the same context of a telecoms \"upstream\" which refers to traffic moving from a subscriber to a provider, or a source control \"upstream\" which refers to where a patch should be sent while \"downstream\" is where the patch comes from.\nWe can't lay the blame for this confusion squarely on Istio and Envoy however, nginx started using the term \"upstream\" this way back in 2004."
  },
  {
    "objectID": "wtfs/wtf_is_nr_filter_chain_not_found.html",
    "href": "wtfs/wtf_is_nr_filter_chain_not_found.html",
    "title": "WTF is NR filter chain not found?",
    "section": "",
    "text": "Figure¬†1: Coffee at Christopher Nolan's place.\n\n\n\n\n\n\n\n\n\ntl;dr Your client is probably not sending the correct SNI during TLS handshake. Try this instead: curl --resolve &lt;your-domain-here&gt;:443:&lt;your_ingress_gateway_public_ip_here&gt; https://&lt;your-domain-here&gt;\n\n\n\n\nWTF Is A Filter Chain?\nEnvoy supports an exceptional amount of flexibility by providing an extensive library of \"proxy primitives\" and allowing users to compose them together. Think of it like doing for network processing what redirection, pipes, and command substitution does for composing a flexible assemblage of shell programs.\n\n\n\n\nFigure¬†2: Nonsense.\n\n\n\nEnvoy calls these proxy primitives \"filters\" and when they're wired together that's (you guessed it!) a filter chain. Instead of doing things like drawing ASCII art and randomizing lines of text, Envoy filters do things like decode protocols, collect statistics, and route traffic.\n\n\nWhy Can't It Be Found?\nNot long after users got accustomed to building out complex filter chains they wanted a way to do branching logic. Specifically, they wanted a way to do things like decrypting some TLS traffic while blindly forwarding the rest to be handled elsewhere.\n\n\nIF tls.SNI == \"foo.com\" THEN\n  decrypt_with(\"./foo.pem\")\nELSE\n  route_to(\"default_upstream.io\")\nFigure¬†3: Pseudocode. Envoy config looks nothing like this.\n\n\nThe configuration structure which supports this type of branching is called a filter chain match and it allows users to examine the properties of an incoming connection and then choose an arbitrary filter chain to process that connection based on the properties it finds.\nIstio leverages Envoy filter chain matching to support use cases like hosting multiple domains on a single ingress gateway and choosing a different TLS certificate depending on the SNI of the incoming request. But crucially, when Istio creates this configuration, there is no ELSE clause.\n\n\nIF tls.SNI == \"foo.com\" THEN\n  decrypt_with(\"./foo.pem\")\nELIF tls.SNI == \"bar.com\" THEN\n  decrypt_with(\"./bar.pem\")\nELSE\n  // what happens here?\nFigure¬†4: Filter chain not found is what!\n\n\n\n\nNow What?\nAssuming your Gateway and VirtualService (or HTTPRoute if you're going Gateway API) resources are all correct, the most likely culprit is that your client application is not actually sending the correct SNI during the TLS handshake. Let me guess, where you trying something like this?\n$ curl --header \"host: yourdomain.com\" https://&lt;your_ingress_gw_ip_here&gt;\ncurl: (35) Recv failure: Connection reset by peer\nAnd then you get something like this in your ingress gateway logs?\n[2025-02-05T20:43:48.376Z] \"- - -\" 0 NR filter_chain_not_found - \"-\" 0 0 8 - \"-\" \"-\" \"-\" \"-\" \"-\" - - 10.42.0.145:8443 10.42.0.1:49186 - -\nThe explanation is hidden three -v's deep in the curl logs, but the short answer is that spoofing the host header is insufficient to cause curl to send the specified hostname as the SNI value during TLS client hello. You need to override DNS resolution to get curl to send the desired SNI.\n\n\n\n\n$ curl -vvv -H \"host: istio.wtf\" https://52.94.236.248\n16:02:18.398120 [0-x] == Info: [READ] client_reset, clear readers\n16:02:18.399595 [0-0] == Info: [HTTPS-CONNECT] added\n16:02:18.399658 [0-0] == Info: [HTTPS-CONNECT] connect, init\n16:02:18.399708 [0-0] == Info: [HTTPS-CONNECT] connect, check h21\n16:02:18.399805 [0-0] == Info:   Trying 52.94.236.248:443...\n16:02:18.400047 [0-0] == Info: [HTTPS-CONNECT] connect -&gt; 0, done=0\n16:02:18.400114 [0-0] == Info: [HTTPS-CONNECT] adjust_pollset -&gt; 1 socks\n16:02:18.400211 [0-0] == Info: [HTTPS-CONNECT] connect, check h21\n16:02:18.400288 [0-0] == Info: [HTTPS-CONNECT] connect -&gt; 0, done=0\n16:02:18.400343 [0-0] == Info: [HTTPS-CONNECT] adjust_pollset -&gt; 1 socks\n16:02:18.439711 [0-0] == Info: [HTTPS-CONNECT] connect, check h21\n16:02:18.439813 [0-0] == Info: [SSL] cf_connect()\n16:02:18.441477 [0-0] == Info: [SSL] No session ID for https://52.94.236.248:443\n16:02:18.441577 [0-0] == Info: ALPN: curl offers h2,http/1.1\n16:02:18.441764 [0-0] =&gt; Send SSL data, 5 bytes (0x5)\n0000: .....\n16:02:18.441825 [0-0] == Info: TLSv1.3 (OUT), TLS handshake, Client hello (1):\n16:02:18.441894 [0-0] =&gt; Send SSL data, 512 bytes (0x200)\n0000: ......`.&gt;]..Fw.......\"..]J.n.nl#lZY..+ .&..S\\)....|$...qpG.1..N.\n0040: .o....Z.&lt;.......,.0.........+./...$.(.k.#.'.g.....9.....3.....=.\n0080: &lt;.5./...w..............................................h2.http/1 üëà\n00c0: .1.........1.....0..............................................\n0100: ...+........-.....3.&.$... Z.M....x..&gt;.S.E.....N..h:X..#........\n0140: ................................................................\n0180: ................................................................\n01c0: ................................................................\nFigure¬†5: Spoofing host header.\n\n\n\n\n$ curl -vvv --resolve istio.wtf:443:52.94.236.248 https://istio.wtf\n16:03:01.892546 [0-x] == Info: Added istio.wtf:443:52.94.236.248 to DNS cache\n16:03:01.892915 [0-x] == Info: [READ] client_reset, clear readers\n16:03:01.892981 [0-0] == Info: Hostname istio.wtf was found in DNS cache\n16:03:01.893041 [0-0] == Info: [HTTPS-CONNECT] added\n16:03:01.893082 [0-0] == Info: [HTTPS-CONNECT] connect, init\n16:03:01.893129 [0-0] == Info: [HTTPS-CONNECT] connect, check h21\n16:03:01.893204 [0-0] == Info:   Trying 52.94.236.248:443...\n16:03:01.893460 [0-0] == Info: [HTTPS-CONNECT] connect -&gt; 0, done=0\n16:03:01.893517 [0-0] == Info: [HTTPS-CONNECT] adjust_pollset -&gt; 1 socks\n16:03:01.929525 [0-0] == Info: [HTTPS-CONNECT] connect, check h21\n16:03:01.929598 [0-0] == Info: [SSL] cf_connect()\n16:03:01.930726 [0-0] == Info: [SSL] No session ID for https://istio.wtf:443\n16:03:01.930806 [0-0] == Info: ALPN: curl offers h2,http/1.1\n16:03:01.930965 [0-0] =&gt; Send SSL data, 5 bytes (0x5)\n0000: .....\n16:03:01.931002 [0-0] == Info: TLSv1.3 (OUT), TLS handshake, Client hello (1):\n16:03:01.931036 [0-0] =&gt; Send SSL data, 512 bytes (0x200)\n0000: .........9..\\.;R..(:.....{WHL.X...w... ...5..*..Sf*....oT..-....\n0040: 3.bB8...&lt;.......,.0.........+./...$.(.k.#.'.g.....9.....3.....=.\n0080: &lt;.5./...w..............istio.wtf................................ üëà\n00c0: .........h2.http/1.1.........1.....0............................\n0100: .....................+........-.....3.&.$... E\\.....I..^.`.iK...\n0140: ......&gt;..bq.V...................................................\n0180: ................................................................\n01c0: ................................................................\nFigure¬†6: Overriding DNS resolution.\n\n\n\n\nEven with the triple -vvv curl doesn't actually parse out the TLS client hello, but if you look closely at the hex dump you can see the DNS override method includes the string istio.wtf while spoofing the host header doesn't."
  },
  {
    "objectID": "wtfs/wtf_is_the_istio_cni.html",
    "href": "wtfs/wtf_is_the_istio_cni.html",
    "title": "WTF is the Istio CNI?",
    "section": "",
    "text": "Figure¬†1: Container network interface.\n\n\n\n\n\n\n\n\n\ntl;dr - Istio is not a typical CNI plugin, the Istio CNI just sets up iptables redirection which forces all pod traffic through the sidecar proxy.\n\n\n\n\nCNI and Plugins\nThe Container Network Interface is the standard by which a container runtime (like Docker or containerd) gives users control over how their containers get connected. A CNI plugin is any application which implements the CNI standard.\nThe workflow goes something like:\n\nSomething asks the runtime to launch a container.\nOnce the container starts, the runtime passes some information like the name of the network interface assigned to the container to the CNI plugin.\nThe CNI plugin executes and returns control to the container runtime.\n\nHere's the important part: usually when the CNI plugin executes it is setting up network connectivity for the container, but not always.\nThe container runtime doesn't actually care if the plugin connected the container to the internet or anything else for that matter, it just cares that the plugin does not return an error. A CNI plugin could just echo \"lol k8s sux\" &gt; /etc/motd for all the container runtime cares.\n\n\nThe Istio CNI\nWhile the Istio CNI does implement the interface making it a valid CNI plugin it does not configure pod-to-pod networking the way other CNI plugins like Calico and Cilium do. All it does is add some iptables rules which force all the traffic going in or out of the main container in the pod to be redirected through the istio-proxy sidecar container which is where all the fancy service mesh stuff happens.\nIstio assumes you already have a CNI plugin capable of configuring pod-to-pod networking and it just steps in after that plugin is finished to add the little bits that Istio needs in order to function.\n\n\nBut Why?\n\n\n\n\n\nThe Istio CNI is totally optional, you can use all the cool features without it. If you do not deploy the Istio CNI what happens instead is that an init container gets added to every pod which has sidecar injection enabled and the init container sets up iptables redirection.\nFor some users however this is a problem because it means whoever or whaetver is putting pods into their cluster requires some highly privileged capabilities. The CNI solves that problem for those users. Instead of giving cluster users the ability to create highly privilged pods, the cluster admins deploy the Istio CNI and give it the necessary capabilities to set up iptables redirection. Now all their users have to do is create a pod with regular privileges and the Istio CNI handles the rest."
  }
]