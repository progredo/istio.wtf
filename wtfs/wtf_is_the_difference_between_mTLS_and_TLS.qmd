---
title: WTF is the difference between mTLS and TLS?
description: "&nbsp;"
---

::: {style="text-align: center"}
[![ketchup or catsup?](media/ketchup-catsup.jpg "A screenshot from an episode of The Simpsons in which Mr. Burns is shopping for groceries and holds up two red condiment bottles; one labeled \"ketchup\" and the other labeled \"catsup\", but the bottels have the letters TLS and mTLS superimposed on them.")](https://imgflip.com/memegenerator/218629870/Simpsons---Ketchup--Catsup)
:::

::: {.callout-tip appearance="simple" icon=false}
**tl;dr** - Istio uses mTLS for in-mesh pod to pod traffic and TLS for traffic entering the mesh from outside the cluster.
:::

### Pod to Pod Traffic

When traffic is sent between two pods which are part of an Istio mesh and mutual TLS is enabled (which is the default), both the [downstream and the upstream](wtf_is_upstream_and_downstream.html) pods will exchange TLS certificates in order to verify the identity of the other pod. Cloudflare has a [decent overview](https://www.cloudflare.com/en-ca/learning/access-management/what-is-mutual-tls/) of the mechanics of this process.

In an Istio mesh the certificates used for this verification come from Istio _itself_ [^1]. At installation time Istio creates a Kubernetes secret in the `istio-system` namespace which contains a self-signed root CA with a 10 year expiry date which it uses to sign all the mTLS client certs it generates. Each pod in the mesh gets its own mTLS client cert and a copy of the Root CA to use for verification. When it sees an incoming request which presents a client cert, it checks the signature to ensure it was signed by the trusted CA and then proceeds to process the traffic.

### Getting Traffic Into Your Cluster

When traffic from the internet arrives at an Istio cluster it is not protected by mTLS. Random web browsers don't trust self signed certs generated by Istio at installation time so they can't participate in mesh traffic. They need something to turn their non-mTLS traffic into mesh traffic protected by mTLS and that something is called an ingress gateway.

Fortunately, Istio gateways support plain old non-mutual TLS for incoming traffic, which is convenient because web browsers do prefer [TLS everywhere](https://www.eff.org/deeplinks/2021/09/https-actually-everywhere). For plain old non-mutual TLS traffic, Istio (like every other web server out there) requires some other authority to mint the certificates it will use. This could be from a commercial vendor like Digicert or a non-profit like LetsEncrypt. The bottom line is that for external clients to communicate securely with an Istio ingress gateway, someone needs to give the gateway a cert to use. Istio cannot mint these itself.

This process could involve just getting a `.pem` file from a provider and manually feeding it to `kubectl create secret ...` or it could leverage a tool like [Cert Manager](https://cert-manager.io/) to automatically provision certs from providers who support such tooling.

In this configuration traffic is protected by vanilla TLS on the way from the client to the ingress gateway, and then mTLS on the way from the ingress gateway to the upstream pod.

```{mermaid}
%%| label: fig-encryption
%%| fig-cap: ¿Por qué no los dos?
%%| fig-align: center
flowchart RL
  client(Web Browser)-- TLS -->ingressgw(Ingress Gateway)
  ingressgw-- mTLS -->pod(Pod)

linkStyle 0 stroke:lightgreen
linkStyle 1 stroke:lightgreen
```

### Summary

 * **mTLS** is used for in cluster pod-to-pod traffic, protected by self signed cert.
 * **TLS**  is used for incoming traffic, protected by a publicly trusted cert.
 * They **can** be used together but they don't **have** to be.

[^1]: By default Istio mints its own mTLS client certs and distributes them to each pod in the mesh, but it can also integrate with other projects which manage workload identites like [SPIRE](https://istio.io/latest/docs/ops/integrations/spire/).
